<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DWH Lineage – Sigma.js (GraphCommons-style)</title>

  <!-- Sigma v2 и Graphology (стабильные UMD-сборки) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>

  <!-- Ваш граф -->
  <script src="data.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #f4f5f7;
      color: #222;
    }

    /* Верхняя панель */
    #top-bar {
      height: 48px;
      display: flex;
      align-items: center;
      padding: 0 14px;
      border-bottom: 1px solid #dde2ec;
      background: #ffffff;
      gap: 10px;
      font-size: 12px;
    }
    #top-title {
      font-weight: 600;
      color: #2c3e50;
      margin-right: 12px;
    }
    #top-search {
      flex: 1;
      max-width: 420px;
    }
    #search-input {
      width: 100%;
      padding: 5px 9px;
      border-radius: 4px;
      border: 1px solid #c6cfdd;
      font-size: 12px;
    }

    #main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 1fr 320px;
      grid-template-rows: 1fr 60px;
      grid-template-areas:
        "left center right"
        "bottom bottom bottom";
      height: calc(100vh - 48px);
    }

    #left-panel {
      grid-area: left;
      border-right: 1px solid #dde2ec;
      background: #f9fafc;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      font-size: 12px;
    }
    #graph-container {
      grid-area: center;
      position: relative;
      background: #ffffff;
    }
    #graph {
      width: 100%;
      height: 100%;
    }
    #right-panel {
      grid-area: right;
      border-left: 1px solid #dde2ec;
      background: #ffffff;
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      font-size: 12px;
    }
    #bottom-panel {
      grid-area: bottom;
      border-top: 1px solid #dde2ec;
      background: #f9fafc;
      padding: 6px 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      font-size: 11px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #7284a3;
      margin: 6px 0 4px;
    }
    .small-label {
      font-size: 11px;
      color: #7b8598;
      margin-top: 2px;
    }

    #search-results {
      margin-top: 6px;
      flex: 1;
      overflow-y: auto;
    }
    .search-item {
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .search-item:hover {
      background: #e9f0ff;
    }

    .type-chip {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .type-chip.TABLE { background: #e5eeff; color: #3366ff; }
    .type-chip.VIEW  { background: #e3fbf3; color: #1a9f6b; }
    .type-chip.PROC  { background: #fff4e3; color: #cb7c07; }
    .type-chip.JOB   { background: #ffe7ea; color: #d64255; }

    .pill {
      padding: 2px 6px;
      border-radius: 12px;
      border: 1px solid #c6cfdd;
      background: #ffffff;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .pill input {
      margin: 0;
    }

    #passport-name {
      font-size: 14px;
      font-weight: 600;
      color: #2c3e50;
      word-break: break-all;
    }
    #passport-meta {
      font-size: 11px;
      color: #7b8598;
      margin-bottom: 8px;
    }
    #passport-empty {
      font-size: 12px;
      color: #7b8598;
      margin-top: 10px;
    }

    .edge-group-header {
      font-size: 11px;
      font-weight: 600;
      color: #4c5c7b;
      margin-top: 6px;
      margin-bottom: 2px;
    }
    .edge-count {
      font-size: 11px;
      color: #7b8598;
      margin-left: 4px;
    }
    .edge-item {
      font-size: 12px;
      padding: 2px 0;
      display: flex;
      justify-content: space-between;
      gap: 4px;
    }
    .edge-item span {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .edge-item-badge {
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 999px;
      border: 1px solid #d0d7e5;
      color: #7b8598;
    }
  </style>
</head>
<body>

<div id="top-bar">
  <div id="top-title">DWH Lineage</div>
  <div id="top-search">
    <input id="search-input" type="text" placeholder="Search node by name (owner.object, full id)" />
  </div>
</div>

<div id="main">
  <!-- Левая панель: результаты поиска -->
  <div id="left-panel">
    <div class="section-title">Search results</div>
    <div class="small-label">Matches for current query</div>
    <div id="search-results"></div>
  </div>

  <!-- Центр: граф -->
  <div id="graph-container">
    <div id="graph"></div>
  </div>

  <!-- Правая панель: паспорт узла -->
  <div id="right-panel">
    <div class="section-title">Node</div>
    <div id="passport-empty">Select a node in the graph or from search.</div>

    <div id="passport-content" style="display:none;">
      <div id="passport-name"></div>
      <div id="passport-meta"></div>

      <div class="section-title">Outgoing</div>
      <div id="passport-outgoing"></div>

      <div class="section-title">Incoming</div>
      <div id="passport-incoming"></div>
    </div>
  </div>

  <!-- Нижняя панель: фильтры -->
  <div id="bottom-panel">
    <span style="font-weight:600;">Filters:</span>

    <div id="filter-element-types"></div>
    <div id="filter-edge-types"></div>

    <!-- degree-фильтр -->
    <div style="display:flex; align-items:center; gap:4px;">
      <span class="small-label">Degree:</span>
      <select id="degree-op">
        <option value="none">off</option>
        <option value=">=">&gt;=</option>
        <option value=">">&gt;</option>
        <option value="=">=</option>
        <option value="<=">&lt;=</option>
        <option value="<">&lt;</option>
      </select>
      <input id="degree-value" type="number" min="0"
             style="width:60px; padding:2px 4px; font-size:11px;" />
    </div>

    <label class="pill">
      <input id="hide-filtered" type="checkbox" />
      hide filtered-out
    </label>

    <button id="relayout-btn" style="font-size:11px; padding:3px 8px;">Relayout</button>
  </div>
</div>

<script>
  // ---- Цвета по типам (узлы и связи) ----
  const NODE_COLORS = {
    TABLE: "#9b59b6",
    VIEW:  "#1abc9c",
    PROC:  "#e67e22",
    JOB:   "#e74c3c",
    default: "#7f8c8d"
  };

  const EDGE_COLORS = {
    USES:    "#bdc3c7",
    CALLS:   "#1abc9c",
    INSERTS: "#f1c40f",
    UPDATES: "#e74c3c",
    default: "#bdc3c7"
  };

  // ---- Строим graphology-граф из GRAPH_DATA ----
  const graph = new graphology.Graph({ type: "directed" });

  const nodes = GRAPH_DATA.nodes || [];
  const edges = GRAPH_DATA.edges || [];

  const N = nodes.length || 1;
  nodes.forEach((n, i) => {
    const angle = (2 * Math.PI * i) / N;
    const x = Math.cos(angle);
    const y = Math.sin(angle);

    const id = n.id;
    if (!graph.hasNode(id)) {
      graph.addNode(id, {
        label: n.label || id,
        type: n.type || "UNKNOWN",
        owner: n.owner || "",
        object: n.object || "",
        x,
        y,
        size: 3,
        color: NODE_COLORS[n.type] || NODE_COLORS.default
      });
    }
  });

  edges.forEach((e, idx) => {
    const src = e.source;
    const tgt = e.target;
    if (!graph.hasNode(src) || !graph.hasNode(tgt)) return;

    const edgeId = e.id || `${src}->${tgt}#${idx}`;
    if (!graph.hasEdge(edgeId)) {
      graph.addDirectedEdgeWithKey(edgeId, src, tgt, {
        type: e.type || "USES",
        color: EDGE_COLORS[e.type] || EDGE_COLORS.default,
        size: 0.6
      });
    }
  });

  // degree для размера нод
  graph.forEachNode((key, attr) => {
    const d = graph.degree(key);
    graph.setNodeAttribute(key, "degree", d);
    graph.setNodeAttribute(key, "size", 2 + Math.log2(1 + d));
  });

  // ---- Инициализируем Sigma ----
  const container = document.getElementById("graph");
  const renderer = new sigma.Sigma(graph, container, {
    renderLabels: true,
    enableEdgeHoverEvents: true,
    zIndex: true
  });

  // Мягкий zoom
  renderer.getCamera().setState({ ratio: 1 });
  renderer.getMouseCaptor().settings.zoomRatio = 1.1;

  // ---- Глобальное состояние фильтров и выделения ----
  let filterState = {
    searchQuery: "",
    elementTypes: new Set(),   // если Set пустой – считаем, что все типы разрешены
    edgeTypes: new Set(),
    degreeOp: "none",
    degreeValue: null,
    hideFiltered: false
  };

  let hoveredNode = null;
  let selectedNode = null;
  let currentZoom = 1;

  // Helper: проверка degree
  function nodePassesDegree(nodeKey) {
    const attrs = graph.getNodeAttributes(nodeKey);
    const d = attrs.degree || graph.degree(nodeKey);
    const op = filterState.degreeOp;
    const val = filterState.degreeValue;

    if (!op || op === "none" || val === null || isNaN(val)) return true;

    if (op === ">=") return d >= val;
    if (op === ">")  return d >  val;
    if (op === "=")  return d === val;
    if (op === "<=") return d <= val;
    if (op === "<")  return d <  val;
    return true;
  }

  // Helper: узел проходит фильтр?
  function nodePassesFilters(nodeKey) {
    const attrs = graph.getNodeAttributes(nodeKey);

    // тип
    if (filterState.elementTypes.size > 0 &&
        !filterState.elementTypes.has(attrs.type)) {
      return false;
    }

    // degree
    if (!nodePassesDegree(nodeKey)) return false;

    // поиск
    if (filterState.searchQuery) {
      const q = filterState.searchQuery;
      const text = ((attrs.label || "") + "|" + nodeKey + "|" + (attrs.object || ""))
        .toLowerCase();
      if (!text.includes(q)) return false;
    }

    return true;
  }

  // Helper: ребро проходит фильтр?
  function edgePassesFilters(edgeKey) {
    const attrs = graph.getEdgeAttributes(edgeKey);

    // тип связи
    if (filterState.edgeTypes.size > 0 &&
        !filterState.edgeTypes.has(attrs.type)) {
      return false;
    }

    const src = graph.source(edgeKey);
    const tgt = graph.target(edgeKey);

    // узлы должны проходить фильтр
    if (!nodePassesFilters(src) || !nodePassesFilters(tgt)) {
      return false;
    }

    return true;
  }

  // ---- Reducers для Sigma (фильтры + hover) ----
  function applyReducers() {
    renderer.setSetting("nodeReducer", (key, data) => {
      const baseVisible = nodePassesFilters(key);
      const res = { ...data };

      if (filterState.hideFiltered && !baseVisible) {
        res.hidden = true;
        return res;
      }

      res.hidden = false;

      // приглушение отфильтрованных, если не hide
      if (!baseVisible) {
        res.color = "#e0e0e0";
        res.opacity = 0.1;
      } else {
        res.opacity = 1;
      }

      // логика по zoom: крупный масштаб → больше подписей, мелкий → только крупные
      const deg = data.degree || 0;
      if (currentZoom < 0.35) {
        res.label = deg >= 30 ? data.label : "";
      } else if (currentZoom < 0.7) {
        res.label = deg >= 8 ? data.label : "";
      } else {
        res.label = data.label;
      }

      // hover: подсветка соседа и самого узла
      if (hoveredNode) {
        const isHovered = key === hoveredNode;
        const isNeighbor =
          graph.hasEdge(hoveredNode, key) || graph.hasEdge(key, hoveredNode);

        if (!isHovered && !isNeighbor) {
          res.color = "#e0e0e0";
          res.opacity = baseVisible ? 0.15 : 0.05;
        } else {
          res.opacity = 1;
        }
      }

      // selected node: можем немного увеличить
      if (selectedNode === key) {
        res.size = (data.size || 3) * 1.3;
      }

      return res;
    });

    renderer.setSetting("edgeReducer", (key, data) => {
      const baseVisible = edgePassesFilters(key);
      const res = { ...data };

      if (filterState.hideFiltered && !baseVisible) {
        res.hidden = true;
        return res;
      }

      res.hidden = false;
      res.opacity = baseVisible ? 0.8 : 0.1;
      res.color = baseVisible ? (EDGE_COLORS[data.type] || EDGE_COLORS.default) : "#e0e0e0";
      res.size = baseVisible ? (data.size || 0.6) : 0.2;

      if (hoveredNode) {
        const src = graph.source(key);
        const tgt = graph.target(key);
        const isRelated = src === hoveredNode || tgt === hoveredNode;
        if (!isRelated) {
          res.opacity = baseVisible ? 0.1 : 0.02;
        } else {
          res.opacity = 1;
          res.size = (data.size || 0.6) * 1.6;
        }
      }

      return res;
    });

    renderer.refresh();
  }

  applyReducers();

  // ---- Обновление currentZoom ----
  renderer.getCamera().on("updated", (e) => {
    currentZoom = e.ratio;
    applyReducers();
  });

  // ---- Hover события ----
  renderer.on("enterNode", ({ node }) => {
    hoveredNode = node;
    applyReducers();
  });

  renderer.on("leaveNode", () => {
    hoveredNode = null;
    applyReducers();
  });

  // ---- Поиск (верхнее поле + левая панель) ----
  const searchInput = document.getElementById("search-input");
  const searchResultsDiv = document.getElementById("search-results");

  function renderSearchResults() {
    const q = filterState.searchQuery;
    searchResultsDiv.innerHTML = "";
    if (!q) return;

    const matches = [];
    graph.forEachNode((n, attrs) => {
      const text = ((attrs.label || "") + "|" + n + "|" + (attrs.object || "")).toLowerCase();
      if (text.includes(q)) matches.push({ id: n, attrs });
    });

    matches.sort((a, b) =>
      (a.attrs.label || a.id).localeCompare(b.attrs.label || b.id)
    );

    matches.forEach(({ id, attrs }) => {
      const div = document.createElement("div");
      div.className = "search-item";
      div.innerHTML = `
        <span title="${attrs.label}">${attrs.label}</span>
        <span class="type-chip ${attrs.type}">${attrs.type}</span>
      `;
      div.onclick = () => focusNode(id);
      searchResultsDiv.appendChild(div);
    });
  }

  searchInput.addEventListener("input", () => {
    const q = searchInput.value.trim().toLowerCase();
    filterState.searchQuery = q || "";
    applyReducers();
    renderSearchResults();
  });

  // ---- Паспорт узла ----
  const passportEmpty    = document.getElementById("passport-empty");
  const passportContent  = document.getElementById("passport-content");
  const passportName     = document.getElementById("passport-name");
  const passportMeta     = document.getElementById("passport-meta");
  const passportOutgoing = document.getElementById("passport-outgoing");
  const passportIncoming = document.getElementById("passport-incoming");

  function clearPassport() {
    passportEmpty.style.display = "block";
    passportContent.style.display = "none";
    passportOutgoing.innerHTML = "";
    passportIncoming.innerHTML = "";
  }

  function renderEdgeGroup(container, title, edgesList, direction) {
    if (!edgesList.length) return;

    const header = document.createElement("div");
    header.className = "edge-group-header";
    header.textContent = title;
    const cntSpan = document.createElement("span");
    cntSpan.className = "edge-count";
    cntSpan.textContent = `(${edgesList.length})`;
    header.appendChild(cntSpan);
    container.appendChild(header);

    edgesList.forEach(edgeKey => {
      const src = graph.source(edgeKey);
      const tgt = graph.target(edgeKey);
      const nodeKey = (direction === "out") ? tgt : src;
      const attrs = graph.getNodeAttributes(nodeKey);

      const row = document.createElement("div");
      row.className = "edge-item";
      row.innerHTML = `
        <span title="${attrs.label}">${attrs.label}</span>
        <span class="edge-item-badge">${attrs.type}</span>
      `;
      row.onclick = () => focusNode(nodeKey);
      container.appendChild(row);
    });
  }

  function updatePassport(nodeKey) {
    if (!nodeKey || !graph.hasNode(nodeKey)) {
      clearPassport();
      return;
    }

    const attrs = graph.getNodeAttributes(nodeKey);
    passportEmpty.style.display = "none";
    passportContent.style.display = "block";

    passportName.textContent = attrs.label || nodeKey;
    passportMeta.textContent =
      (attrs.type || "-") + " · " + (attrs.owner || "-") + " · " + (attrs.object || "");

    passportOutgoing.innerHTML = "";
    passportIncoming.innerHTML = "";

    const outgoingByType = { CALLS: [], USES: [], INSERTS: [], UPDATES: [] };
    const incomingByType = { CALLS: [], USES: [], INSERTS: [], UPDATES: [] };

    graph.forEachOutEdge(nodeKey, (edgeKey, _attrs, src, tgt, _extra) => {
      const et = graph.getEdgeAttribute(edgeKey, "type") || "USES";
      if (!outgoingByType[et]) outgoingByType[et] = [];
      outgoingByType[et].push(edgeKey);
    });

    graph.forEachInEdge(nodeKey, (edgeKey, _attrs, src, tgt, _extra) => {
      const et = graph.getEdgeAttribute(edgeKey, "type") || "USES";
      if (!incomingByType[et]) incomingByType[et] = [];
      incomingByType[et].push(edgeKey);
    });

    renderEdgeGroup(passportOutgoing, "CALLS",   outgoingByType.CALLS,   "out");
    renderEdgeGroup(passportOutgoing, "USES",    outgoingByType.USES,    "out");
    renderEdgeGroup(passportOutgoing, "INSERTS", outgoingByType.INSERTS, "out");
    renderEdgeGroup(passportOutgoing, "UPDATES", outgoingByType.UPDATES, "out");

    renderEdgeGroup(passportIncoming, "CALLS",   incomingByType.CALLS,   "in");
    renderEdgeGroup(passportIncoming, "USES",    incomingByType.USES,    "in");
    renderEdgeGroup(passportIncoming, "INSERTS", incomingByType.INSERTS, "in");
    renderEdgeGroup(passportIncoming, "UPDATES", incomingByType.UPDATES, "in");
  }

  // ---- Фокус на узел (центрирование + zoom + паспорт) ----
  function focusNode(nodeKey) {
    if (!graph.hasNode(nodeKey)) return;
    selectedNode = nodeKey;
    updatePassport(nodeKey);
    applyReducers();

    const pos = renderer.getNodeDisplayData(nodeKey);
    if (!pos) return;

    renderer.getCamera().animate(
      { x: pos.x, y: pos.y, ratio: 0.4 },
      { duration: 350 }
    );
  }

  // ---- Клик по узлу на графе ----
  renderer.on("clickNode", ({ node }) => {
    focusNode(node);
  });

  // ---- Клик по пустому полю ----
  renderer.on("clickStage", () => {
    selectedNode = null;
    clearPassport();
    applyReducers();
  });

  // ---- Нижние фильтры (типы узлов, типы связей, degree, hide) ----
  const filterElementTypesDiv = document.getElementById("filter-element-types");
  const filterEdgeTypesDiv    = document.getElementById("filter-edge-types");
  const degreeOpSelect        = document.getElementById("degree-op");
  const degreeValueInput      = document.getElementById("degree-value");
  const hideFilteredCheckbox  = document.getElementById("hide-filtered");
  const relayoutBtn           = document.getElementById("relayout-btn");

  const elementTypes = Array.from(
    new Set(nodes.map(n => n.type || "UNKNOWN"))
  ).sort();

  const edgeTypes = Array.from(
    new Set(edges.map(e => e.type || "USES"))
  ).sort();

  function createFilterSection(container, label, values, typeKey) {
    const title = document.createElement("span");
    title.className = "small-label";
    title.style.marginRight = "4px";
    title.textContent = label + ":";
    container.appendChild(title);

    values.forEach(v => {
      const pill = document.createElement("label");
      pill.className = "pill";
      const id = `filter-${typeKey}-${v}`;
      pill.innerHTML = `<input type="checkbox" id="${id}" checked> ${v}`;
      pill.querySelector("input").addEventListener("change", () => {
        rebuildFilterState();
      });
      container.appendChild(pill);
    });
  }

  createFilterSection(filterElementTypesDiv, "element type", elementTypes, "elem");
  createFilterSection(filterEdgeTypesDiv,    "connection type", edgeTypes,  "edge");

  function rebuildFilterState() {
    // element types
    const elemChecked = new Set(
      Array.from(filterElementTypesDiv.querySelectorAll("input:checked"))
        .map(inp => inp.parentElement.textContent.trim())
    );
    const edgeChecked = new Set(
      Array.from(filterEdgeTypesDiv.querySelectorAll("input:checked"))
        .map(inp => inp.parentElement.textContent.trim())
    );

    filterState.elementTypes = elemChecked;
    filterState.edgeTypes    = edgeChecked;
    filterState.degreeOp     = degreeOpSelect.value;
    const valStr = degreeValueInput.value;
    filterState.degreeValue  = valStr ? parseInt(valStr, 10) : null;
    filterState.hideFiltered = hideFilteredCheckbox.checked;

    applyReducers();
  }

  degreeOpSelect.addEventListener("change", rebuildFilterState);
  degreeValueInput.addEventListener("input", rebuildFilterState);
  hideFilteredCheckbox.addEventListener("change", rebuildFilterState);

  // простой relayout: заново круг
  relayoutBtn.addEventListener("click", () => {
    const n = graph.order || 1;
    let i = 0;
    graph.forEachNode((key, attr) => {
      const angle = (2 * Math.PI * i) / n;
      graph.setNodeAttribute(key, "x", Math.cos(angle));
      graph.setNodeAttribute(key, "y", Math.sin(angle));
      i += 1;
    });
    renderer.refresh();
  });

  // начальный рендер
  rebuildFilterState();
  clearPassport();
</script>

</body>
</html>
